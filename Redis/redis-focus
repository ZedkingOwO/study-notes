

redis三个系统优化：
    全连接队列最大值（Ubuntu22.04默认值满足）：
    内存透明大页（Ubuntu22.04默认值满足要求）：
    内存分配策略（需要调整）：
                    0、 有就给没有就不给
                    1、 所有物理内存
                    2、 物理和交换的总合
内存偏移：
    内存碎片
        内存淘汰策略
        包括最大内存
        内存分配策略

为什么redis是进程多线程性能好:
    避免了线程上下文切换/纯内存

Redis支持哪些数据类型：
    String（字符串）、Hash（哈希）、List（列表）、Set（集合）、Sorted Set（有序集合）


生产者消费者模型

发布者订阅者模式


缓存问题：
    缓存雪崩：
        缓存雪崩指的是当缓存中的大量数据同时失效或过期时所引发的问题，
        导致大量的请求直接击中数据库，造成系统负载剧增，甚至引起系统崩溃。 key永不过期
    缓存击穿：
        缓存击穿指的是针对某个特定的缓存键（key）进行的大量请求，而这个缓存键对应的数据刚好失效或不存在，
        导致大量请求直接访问数据库。与缓存雪崩不同的是，缓存击穿通常是针对某个特定的缓存键而言。 互斥锁
    缓存穿透：
        缓存穿透指的是恶意请求针对缓存中不存在的数据，而这些请求会直接穿透缓存层，直接访问数据库或后端系统。
        这种情况可能会导致数据库或后端系统负载过大。用布隆过滤器（Bloom Filter）等技术来过滤恶意请求。






Redis持久化机制：
    redis info 中有一条可以判断备份是否结束：reb_bgsave_in_progress:0
    RDB：
        快照：类似于mysql中的完全备份;
        Redis的内存数据以快照的方式写入到磁盘上的一个文件中,这个文件包含了Redis在某个时间点上的全量数据。
        Save命令: 是占用Redis工作线程完成备份的，工作线程只有一个这就意味着备份不完成，其他写入操作要被阻塞。
        Bgsave命令：当执行BGSAVE命令时，Redis会fork一个子进程。子进程负责将当前内存中的数据集写入到一个临时 tmp_子进程pid.RDB 文件中，
                   而父进程则继续处理客户端的请求。在子进程完成数据写入后，Redis会用这个RDB文件覆盖之前的旧RDB文件。 
                   如果直接写入原本的RDB文件，如果备份过程中出错，那么原来的RDB被破坏。
        当Redis启动时，它会尝试从磁盘上的RDB文件中加载数据。如果有RDB文件存在，则Redis会使用这个文件来恢复数据。
        
        优缺点:
            对于备份和迁移来说，RDB文件更加简单
            RDB不是实时写入，如果为了数据完整性提高备份频率，
            频繁的持久化操作可能会对性能产生一定影响，因为Redis是将数据快照写入磁盘的方式完成的。
   
    AOF:（AOF优先级比RDB高）
        逻辑备份：类似于Mysql二进制日志；
        附加式备份，在第一次开启AOF他会先做一次完全备份，后续使用增量备份；
        注意：第一次开启AOF的时候如果有数据要动态修改配置，如果重启内存数据都在RDB中，但是由于开启了AOF，优先级高，他就会加载AOF中的数据，AOF没数据。第一次开启AOF要动态修改配置，然后再去配置文件中修改。
        原理：
        AOF持久化通过将Redis的写命令追加到一个只写文件中。这些写命令以Redis协议格式记录在文件中，从而使得文件中包含了可以重放以恢复原始数据集的所有写操作。

        优缺点：
            AOF文件包含了数据的操作历史，可以很好地保护数据免受丢失并且是实时写入。
            对于故障恢复来说，AOF文件通常比RDB文件更可靠，因为它包含了操作历史，可以删除错误命令的执行过程，可以更精确地恢复数据。

            AOF文件通常比RDB文件更大，因为它包含了每个写命令的历史记录。
            由于AOF文件需要不断地追加写命令，因此在高写入负载下，AOF持久化可能会产生较高的磁盘IO开销。


Redis部署：
    单节点模式：
        简单易部署和管理，适用于小型应用或开发环境，资源消耗低，占用较少的内存和CPU，成本低。
        单点故障风险高，没有故障恢复机制，没有数据冗余和高可用性。
    主从复制模式：
        主节点故障时可以手动将从节点晋升为新的主节点。支持数据冗余，从节点用于读操作，减轻主节点的负载。
        故障转移需要手动干预，主节点的性能可能成为瓶颈，无法横向扩展。
    Sentinel模式：
        提供了自动化的故障转移机制，当主节点故障时可以自动将从节点晋升为新的主节点。提供了监控和通知功能，可实时监控Redis集群的健康状态。
        配置和管理复杂度较高，故障转移可能会导致一段时间内的服务中断。（升级版的主从，但是没有解决主节点横向扩展）
    Cluster模式：
        提供了自动化的数据分片和故障转移机制，无需手动干预即可实现数据的高可用性和可扩展性。支持水平扩展，可以根据需求方便地增加节点。
        成本，部署和管理复杂度较高。


Redis主从原理：
    从节点向主节点发送Psync？-1 指令,尝试连接主节点并进行身份验证，
    建立连接后，主节点向从节点发送FULLRESYNC指令、master repliid 和offset（完全同步，和自己的IDoffset）
    从节点保存主节点发送的信息;
    主节点执行BGsave保存当前内存中的所有数据RDB文件，然后把RDB文件发送从节点;
    如果再同步过程中有新的数据产生，主节点会写到自己的缓冲区中，然后把缓冲区的数据也发给从节点;
    从节点删除本地数据，加载RDB和缓冲数据;

哨兵工作原理：（注意密码配置）
    用来监控redis主从复制，sentinel不断和主从所有节点通讯，如果发现这个master挂了就找这个主从集群中的slave提升为主节点;
    客户端不在连接master，而是连接sentinel节点，通过sentile节点获取当前主节点的信息，sentinel也要做高可用，客户端通过sentinel获取redis节点信息；

    每个Sentinel进程会向其它Sentinel、10秒 Master、slave定时发送消息，来确认对方是否存活
    如果发现某个节点在指定配置时间内未得到响应，则会认为此节点已离线，即为主观岩机Subjective Down，简称为 SDOWN
    如果哨兵集群中的多数Sentinel进程认为Master存在SDOWN，共同利用 ismaster-down-by.addr 命令豆相通知后，则认为客观宕机Objectively Down，简称ODOWN
    接下来利用投票算法，从所有slave节点中，选一台合适的slave将之提升为新Master节点，然后自动修改其它slave相关配置，指向新的master节点,最终实现故障转移fallover

Cluster的工作原理：
    不论是主从还是哨兵都只能有一个节点可以写，无法解决主节点无法横向扩展。
    我们扩展三个主节点，但没有数据冗余，因此每个主都要配置一个从节点。
    但是客户端面对三个主节点数据该怎么存放：
        通常的做法是获取key的哈希值，对key进行hash计算然后对节点数取模。hash（key）%3
        但这种做法有个闭端，当我们扩缩容时整个计算公式改变，会造成大量的key无法命中。
       
        Redis Cluster 采用虚拟哈希槽分区：计算公式：slot = CRC16(key) % 16383。
            每个key通过CRC16校验后对16384取模来决定放置哪个槽(Slot)，然后每个节点负责维护一部分槽以及槽所映射的键值数据。
            1. 当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；
            2. 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；



redis优化：
    安全：
        当启用保护模式，而且没有密码时，服务器只接受来自IPv4地127.0.0.1(没密码+保护模式启动=本地访问)
        限制接受连接的IP地
        默认安全模式
        限制命令的使用
        防止远程执行
        设置网络和文件系统权限
        定期备份
    

    性能：
        最大内存
        最大连接数
        连接超时时间
        会话保持时间
        ash-max-ziplist-entries / hash-max-ziplist-value: 设置哈希对象编码的优化参数，以控制压缩列表的大小和效率。
